name: Update Repository

on:
  schedule:
    # Hourly sync
    - cron: "0 * * * *"

  workflow_dispatch:
    inputs:
      binary_source:
        description: "Binary source preference"
        required: false
        default: "latest"
        type: choice
        options:
          - latest # Most recent (prerelease or stable)
          - stable # Latest stable release only
          - preview # Latest preview/prerelease only
          - build # Always build from source
      prune:
        description: "Prune unavailable entries after sync"
        required: false
        default: true
        type: boolean
      prune_remove_after:
        description: "Remove entries unavailable for this duration (e.g., 24h, 168h, 720h)"
        required: false
        default: "24h"
        type: string
      prune_incompatible:
        description: "Prune incompatible plugin versions"
        required: false
        default: true
        type: boolean
      keep_recent:
        description: "Keep only N most recent versions per plugin"
        required: false
        default: 5
        type: number
      min_protocol_version:
        description: "Minimum protocol version (leave empty to disable)"
        required: false
        default: ""
        type: string

  # Trigger when repo-manager tool or sync config changes
  push:
    paths:
      - "repository/sync-config.jsonl"
    branches:
      - main

  # Trigger from tinct repository on new releases (both stable and preview)
  # Payload includes: client_payload.release_type (preview/stable) and client_payload.version
  repository_dispatch:
    types: [tinct-release]

jobs:
  update-repository:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine binary source preference
        id: binary_pref
        run: |
          # Determine which binary source to use
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SOURCE_PREF="${{ github.event.inputs.binary_source }}"
          else
            SOURCE_PREF="latest"
          fi
          echo "source_preference=$SOURCE_PREF" >> $GITHUB_OUTPUT
          echo "Binary source preference: $SOURCE_PREF"

          # Capture repository_dispatch payload if present
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            RELEASE_TYPE="${{ github.event.client_payload.release_type }}"
            RELEASE_VERSION="${{ github.event.client_payload.version }}"
            echo "triggered_by=tinct-release" >> $GITHUB_OUTPUT
            echo "tinct_release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tinct_release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
            echo "Triggered by tinct $RELEASE_TYPE release: $RELEASE_VERSION"
          else
            echo "triggered_by=${{ github.event_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Download repo-manager binary
        id: download
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SOURCE_PREF="${{ steps.binary_pref.outputs.source_preference }}"
          echo "Fetching tinct-repo-manager binary (preference: $SOURCE_PREF)..."

          RELEASE_TAG=""
          FOUND_BINARY=false

          if [ "$SOURCE_PREF" = "build" ]; then
            echo "Configured to build from source, skipping download"
            echo "use_binary=false" >> $GITHUB_OUTPUT
            echo "source=built-from-source" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Fetch all releases using gh CLI (more reliable than curl)
          # Explicitly sort by latest first to ensure first match is always the most recent
          echo "Fetching releases using gh CLI..."
          ALL_RELEASES=$(gh release list --repo jmylchreest/tinct --limit 30 --order desc --json tagName,isPrerelease,publishedAt)

          if [ "$SOURCE_PREF" = "latest" ]; then
            # Get the most recent release (prerelease or stable) with binary
            echo "Looking for most recent release (any type)..."
            # Try each release in order until we find one with the required binary
            for TAG in $(echo "$ALL_RELEASES" | jq -r '.[].tagName'); do
              echo "Checking release: $TAG"
              # Try to download the binary for this release
              if gh release download "$TAG" \
                  --repo jmylchreest/tinct \
                  --pattern "*tinct-repo-manager*Linux_x86_64*.tar.gz" \
                  --skip-existing \
                  --dir . 2>/dev/null; then
                RELEASE_TAG="$TAG"
                FOUND_BINARY=true
                echo "Found binary in release: $RELEASE_TAG"
                break
              fi
            done

          elif [ "$SOURCE_PREF" = "stable" ]; then
            # Get latest stable (non-prerelease) only
            echo "Looking for latest stable release..."
            for TAG in $(echo "$ALL_RELEASES" | jq -r '[.[] | select(.isPrerelease == false)] | .[].tagName'); do
              echo "Checking stable release: $TAG"
              if gh release download "$TAG" \
                  --repo jmylchreest/tinct \
                  --pattern "*tinct-repo-manager*Linux_x86_64*.tar.gz" \
                  --skip-existing \
                  --dir . 2>/dev/null; then
                RELEASE_TAG="$TAG"
                FOUND_BINARY=true
                echo "Found binary in stable release: $RELEASE_TAG"
                break
              fi
            done

          elif [ "$SOURCE_PREF" = "preview" ]; then
            # Get latest preview (prerelease) only
            echo "Looking for latest preview release..."
            for TAG in $(echo "$ALL_RELEASES" | jq -r '[.[] | select(.isPrerelease == true)] | .[].tagName'); do
              echo "Checking preview release: $TAG"
              if gh release download "$TAG" \
                  --repo jmylchreest/tinct \
                  --pattern "*tinct-repo-manager*Linux_x86_64*.tar.gz" \
                  --skip-existing \
                  --dir . 2>/dev/null; then
                RELEASE_TAG="$TAG"
                FOUND_BINARY=true
                echo "Found binary in preview release: $RELEASE_TAG"
                break
              fi
            done
          fi

          # Extract and verify
          if [ "$FOUND_BINARY" = false ]; then
            echo "No pre-built binary found, will build from source"
            echo "use_binary=false" >> $GITHUB_OUTPUT
            echo "source=built-from-source" >> $GITHUB_OUTPUT
          else
            echo "Extracting binary from downloaded archive..."
            # Find the downloaded tar.gz file
            TARBALL=$(find . -maxdepth 1 -name "*tinct-repo-manager*Linux_x86_64*.tar.gz" | head -1)
            if [ -z "$TARBALL" ]; then
              echo "Failed to find downloaded archive, will build from source"
              echo "use_binary=false" >> $GITHUB_OUTPUT
              echo "source=built-from-source" >> $GITHUB_OUTPUT
            else
              tar -xzf "$TARBALL"
              chmod +x tinct-repo-manager

              # Verify it works
              if ./tinct-repo-manager --version; then
                echo "use_binary=true" >> $GITHUB_OUTPUT
                echo "source=$RELEASE_TAG" >> $GITHUB_OUTPUT
              else
                echo "Binary check failed, will build from source"
                echo "use_binary=false" >> $GITHUB_OUTPUT
                echo "source=built-from-source" >> $GITHUB_OUTPUT
              fi
            fi
          fi

      - uses: actions/setup-go@v5
        if: steps.download.outputs.use_binary == 'false'
        with:
          go-version: "1.25"

      - name: Build repo-manager from source
        if: steps.download.outputs.use_binary == 'false'
        run: |
          echo "Building tinct-repo-manager from source..."
          cd cmd/tinct-repo-manager
          go build -o ../../tinct-repo-manager

      - name: Determine parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "repository_dispatch" ] || [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event_name }}" = "push" ]; then
            echo "prune=true" >> $GITHUB_OUTPUT
            echo "prune_remove_after=24h" >> $GITHUB_OUTPUT
            echo "prune_incompatible=true" >> $GITHUB_OUTPUT
            echo "keep_recent=5" >> $GITHUB_OUTPUT
            echo "min_protocol_version=" >> $GITHUB_OUTPUT
          else
            echo "prune=${{ github.event.inputs.prune }}" >> $GITHUB_OUTPUT
            echo "prune_remove_after=${{ github.event.inputs.prune_remove_after }}" >> $GITHUB_OUTPUT
            echo "prune_incompatible=${{ github.event.inputs.prune_incompatible }}" >> $GITHUB_OUTPUT
            echo "keep_recent=${{ github.event.inputs.keep_recent }}" >> $GITHUB_OUTPUT
            echo "min_protocol_version=${{ github.event.inputs.min_protocol_version }}" >> $GITHUB_OUTPUT
          fi

      - name: Sync plugins from config
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PRUNE="${{ steps.params.outputs.prune }}"
          PRUNE_REMOVE_AFTER="${{ steps.params.outputs.prune_remove_after }}"
          PRUNE_INCOMPATIBLE="${{ steps.params.outputs.prune_incompatible }}"
          KEEP_RECENT="${{ steps.params.outputs.keep_recent }}"
          MIN_PROTOCOL_VERSION="${{ steps.params.outputs.min_protocol_version }}"

          echo "Syncing plugins from sync-config.jsonl"
          if [ "$PRUNE" = "true" ]; then
            echo "Pruning enabled (remove after $PRUNE_REMOVE_AFTER)"
          fi
          if [ "$PRUNE_INCOMPATIBLE" = "true" ]; then
            echo "Pruning incompatible versions enabled"
          fi
          if [ -n "$KEEP_RECENT" ] && [ "$KEEP_RECENT" != "0" ]; then
            echo "Keeping $KEEP_RECENT most recent versions per plugin"
          fi
          if [ -n "$MIN_PROTOCOL_VERSION" ]; then
            echo "Minimum protocol version: $MIN_PROTOCOL_VERSION"
          fi

          # Build flags
          FLAGS=""
          if [ "$PRUNE" = "true" ]; then
            FLAGS="$FLAGS --prune --prune-remove-after $PRUNE_REMOVE_AFTER"
          fi
          if [ "$PRUNE_INCOMPATIBLE" = "true" ]; then
            FLAGS="$FLAGS --prune-incompatible"
          fi
          if [ -n "$KEEP_RECENT" ] && [ "$KEEP_RECENT" != "0" ]; then
            FLAGS="$FLAGS --keep-recent $KEEP_RECENT"
          fi
          if [ -n "$MIN_PROTOCOL_VERSION" ]; then
            FLAGS="$FLAGS --min-protocol-version $MIN_PROTOCOL_VERSION"
          fi

          # Sync using configuration file with changelog tracking
          ./tinct-repo-manager sync \
            --config repository/sync-config.jsonl \
            --manifest repository/repository.json \
            --changelog-output /tmp/changelog.txt \
            --changelog-format text \
            $FLAGS \
            --verbose

      - name: Validate manifest
        run: |
          echo "Validating manifest..."
          ./tinct-repo-manager validate \
            --manifest repository/repository.json

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet repository/repository.json; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add repository/repository.json

          # Create commit message with changelog
          MSG="chore(repository): sync plugins"
          if [ "${{ steps.params.outputs.prune }}" = "true" ]; then
            MSG="${MSG} with pruning"
          fi

          # Read changelog if available
          if [ -f /tmp/changelog.txt ]; then
            CHANGELOG=$(cat /tmp/changelog.txt)
            git commit -m "$MSG" -m "$CHANGELOG"
          else
            git commit -m "$MSG"
          fi

          git push

      - name: Upload changelog artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sync-changelog-${{ github.run_number }}
          path: /tmp/changelog.txt
          retention-days: 90
          if-no-files-found: ignore

      - name: Summary
        if: always()
        run: |
          echo "## Repository Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Config**: sync-config.jsonl" >> $GITHUB_STEP_SUMMARY
          echo "- **Prune**: ${{ steps.params.outputs.prune }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.params.outputs.prune }}" = "true" ]; then
            echo "- **Prune Remove After**: ${{ steps.params.outputs.prune_remove_after }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Prune Incompatible**: ${{ steps.params.outputs.prune_incompatible }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Keep Recent**: ${{ steps.params.outputs.keep_recent }}" >> $GITHUB_STEP_SUMMARY
          MIN_VER="${{ steps.params.outputs.min_protocol_version }}"
          if [ -n "$MIN_VER" ]; then
            echo "- **Min Protocol Version**: $MIN_VER" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Min Protocol Version**: (disabled)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Changes**: ${{ steps.changes.outputs.changed }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Binary Preference**: ${{ steps.binary_pref.outputs.source_preference }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repo Manager Source**: ${{ steps.download.outputs.source }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By**: ${{ steps.binary_pref.outputs.triggered_by }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.binary_pref.outputs.triggered_by }}" = "tinct-release" ]; then
            echo "- **Tinct Release Type**: ${{ steps.binary_pref.outputs.tinct_release_type }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Tinct Release Version**: ${{ steps.binary_pref.outputs.tinct_release_version }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add changelog to summary if available
          if [ -f /tmp/changelog.txt ]; then
            echo "## Changelog" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat /tmp/changelog.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
